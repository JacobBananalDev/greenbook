# EF Core Migrations – GreenBook

This document explains **what the `dotnet ef migrations add` command does**, why each flag exists, and how we run migrations in GreenBook.

---

## The Command (Annotated)

```powershell
dotnet ef migrations add InitialCreate `
  --project .\GreenBook.Infrastructure `
  --startup-project .\GreenBook.Api `
  --output-dir Persistence\Migrations
```

### What each part means

#### `dotnet ef`

Runs the **Entity Framework Core CLI tool**. This tool:

* Reads your `DbContext`
* Compares your C# entity model to the database
* Generates SQL migration code

Think of it as: **“turn my C# model into SQL changes.”**

---

#### `migrations add InitialCreate`

* `migrations add` → create a new migration
* `InitialCreate` → the **name** of the migration

EF will generate:

* A timestamped migration class
* SQL instructions for creating tables, constraints, indexes

Example generated name:

```
20260128234034_InitialCreate.cs
```

---

#### `--project .\GreenBook.Infrastructure`

Tells EF **where the DbContext and entities live**.

Why this matters in GreenBook:

* `GreenBook.Infrastructure` contains `GreenBookDbContext`
* This project defines the persistence model

Without this flag, EF would guess—and often guess wrong.

---

#### `--startup-project .\GreenBook.Api`

Tells EF **which project to run at design time**.

EF needs a startup project to:

* Load `appsettings.json`
* Resolve the database connection string
* Build dependency injection

In GreenBook:

* The API project owns configuration
* Infrastructure is a class library

This flag bridges that gap.

---

#### `--output-dir Persistence\Migrations`

Controls **where migration files are stored**.

Why we do this:

* Keeps migrations near persistence code
* Avoids cluttering the project root
* Makes intent clear (this is database infrastructure)

Resulting structure:

```
GreenBook.Infrastructure/
  Persistence/
    Migrations/
      2026xxxx_InitialCreate.cs
      GreenBookDbContextModelSnapshot.cs
```

---

## Applying the Migration

After creating a migration, we apply it to the database:

```powershell
dotnet ef database update `
  --project .\GreenBook.Infrastructure `
  --startup-project .\GreenBook.Api
```

What this does:

* Connects to Postgres
* Executes the SQL generated by the migration
* Creates or updates tables

This is when the database actually changes.

---

## Mental Model (Very Important)

**Migrations are versioned SQL, not magic.**

Flow:

1. You change C# entities
2. EF generates migration (diff)
3. Migration becomes SQL
4. SQL runs against Postgres

EF does NOT:

* Watch your DB live
* Automatically change schema
* Guess intent

You control when schema changes happen.

---

## When to Create a Migration

Create a migration when you:

* Add a new entity
* Add/remove a property
* Change constraints or relationships

Do NOT create migrations for:

* Query changes
* API-only changes
* UI changes

---

## Common GreenBook Commands (Copy/Paste)

### Create a new migration

```powershell
dotnet ef migrations add AddRoundsTable `
  --project .\GreenBook.Infrastructure `
  --startup-project .\GreenBook.Api
```

### Apply migrations

```powershell
dotnet ef database update `
  --project .\GreenBook.Infrastructure `
  --startup-project .\GreenBook.Api
```

### Remove last migration (not applied)

```powershell
dotnet ef migrations remove `
  --project .\GreenBook.Infrastructure `
  --startup-project .\GreenBook.Api
```

---

## Why This Setup Is Professional

* Clear separation of concerns
* Database logic isolated in Infrastructure
* API owns runtime configuration
* Repeatable, scriptable workflow

This mirrors how production teams structure EF Core solutions.

---

## Next Steps After This Doc

* Apply initial migration
* Verify tables in Postgres
* Seed sample data
* Build first `POST /rounds` endpoint

---

Last updated for GreenBook (net8, EF Core 8, PostgreSQL)
